#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Database layer translates database calls to functions
#
# Software is free software released under the "GNU Affero General Public License v3.0"
#
# Copyright (c) 2015-2018  Pieter-Jan Moreels - pieterjan.moreels@gmail.com

# imports
import ast
import sys

import pymongo
import re
import uuid

from passlib.hash import pbkdf2_sha256

from lib.Reconnect import reconnect
from lib.Collections import Collections
from lib.Config import Configuration

from pymongo import UpdateOne

# Variables
hash_rounds = 8000
salt_size = 10


# Functions
@reconnect
def sanitize(x):
    if type(x) == pymongo.cursor.Cursor:
        x = list(x)
    if type(x) == list:
        for y in x: sanitize(y)
    if x and "_id" in x: x.pop("_id")
    return x


# DB Functions
@reconnect
def createIndex(collection, field):
    Configuration.getMongoConnection().get_collection(collection).create_index(field)
    # jdt_NOTE: ensure_index() is deprecated since, create_index() should be used instead
    # jdt_NOTE: test possible effects of changes on sbin/db_mgmt_create_index.py
    # db[collection].create_index(field)


@reconnect
def drop(collection):
    Configuration.getMongoConnection()[collection].drop()


@reconnect
def setColUpdate(collection, date):
    Configuration.getMongoConnection().get_collection(Collections.Info.value).update({"db": collection},
                                                                                     {"$set": {"last-modified": date}},
                                                                                     upsert=True)


@reconnect
def setColInfo(collection, field, data):
    Configuration.getMongoConnection().get_collection(Collections.Info.value).update({"db": collection},
                                                                                     {"$set": {field: data}},
                                                                                     upsert=True)


@reconnect
def insertCVE(cve):
    Configuration.getMongoConnection().get_collection(Collections.CVE.value).insert(cve)


@reconnect
def updateCVE(cve):
    Configuration.getMongoConnection().get_collection(Collections.CVE.value) \
        .update({"id": cve['id']}, {
        "$set": {"cvss": cve['cvss'], "summary": cve['summary'], "references": cve['references'],
                 "impact": cve['impact'],
                 "vulnerable_product": cve["vulnerable_product"], "access": cve['access'],
                 "cwe": cve['cwe'], "vulnerable_configuration": cve['vulnerable_configuration'],
                 "vulnerable_configuration_cpe_2_2": cve['vulnerable_configuration_cpe_2_2'],
                 'last-modified': cve['Modified']}})


@reconnect
def bulkInsert(collection, data):
    if len(data) > 0:
        bulk = Configuration.getMongoConnection().get_collection(collection).initialize_unordered_bulk_op()
        for x in data:
            bulk.insert(x)
        bulk.execute()


@reconnect
def bulkUpdate(collection, data):
    if len(data) < 1:
        return

    batch = []
    count = 1000
    print("Beginning bulk update of {} items".format(str(len(data))))
    for d in data:
        batch.append(
            UpdateOne(
                {"id": d["id"]},
                {"$set": d},
                upsert=True
            )
        )
        if len(batch) == 1000:
            Configuration.getMongoConnection().get_collection(collection).bulk_write(batch)
            print("Updated {}/{} items".format(str(count), str(len(data))))
            batch = []
            count += 1000
    if len(batch) > 0:
        Configuration.getMongoConnection().get_collection(collection).bulk_write(batch)
        count += len(batch)
        print("Updated {}/{} items.".format(str(count), str(len(data))))
    print("Finished bulk update.")

    # bulk=db[collection].initialize_unordered_bulk_op()
    # for x in data:
    #  bulk.find({'id': x['id']}).upsert().update({'$set': x})
    # bulk.execute()
    # jdt_NOTE: initialize_ordered_bulk_op(), initialize_unordered_bulk_op(), BulkOperationBuilder are deprecated, bulk_write() should be used instead
    # jdt_NOTE: test possible effects of changes on sbin/db_mgmt_ref.py, sbin/db_mgmt_capec.py, sbin/db_mgmt_cwe.py, sbin/db_mgmt_cpe_dictionary.py
    # requests = []
    # for x in data:
    #    requests.append(UpdateOne({'id': x['id']}, {'$set': x}, upsert=True))
    # result = db[collection].bulk_write(requests)


@reconnect
def cpeotherBulkInsert(cpeotherlist):
    Configuration.getMongoConnection().get_collection(Collections.CPEOther.value).insert(cpeotherlist)


@reconnect
def dropCollection(col):
    return Configuration.getMongoConnection().get_collection(col).drop()
    # jdt_NOTE: is exactly the same as drop(collection)
    # jdt_NOTE: use only one of them


@reconnect
def getTableNames():
    return Configuration.getMongoConnection().collection_names()
    # jdt_NOTE: collection_names() is depreated, list_collection_names() should be used instead
    # return db.list_collection_names()


# returns True if 'target_version' is less or equal than
# 'cpe_version'
# returns False otherwise
def target_version_is_included(target_version, cpe_version):
    sp_target = target_version.split(".")
    sp_cpe = cpe_version.split(".")
    if len(sp_target) > len(sp_cpe):
        sp_cpe += [0] * (len(sp_target) - len(sp_cpe))
    if len(sp_cpe) > len(sp_target):
        sp_cpe += [0] * (len(sp_cpe) - len(sp_target))
    for i in range(len(sp_target)):
        # target version smaller than cpe version
        if int(sp_target[i]) < int(sp_cpe[i]):
            return True
        # target version greater than cpe version
        if int(sp_target[i]) > int(sp_cpe[i]):
            return False
    # target version same version as cpe version
    return True


# API Functions
@reconnect
def cvesForCPE(cpe, lax=False, vulnProdSearch=False):
    if not cpe: return []
    cpe_regex = cpe
    final_cves = []
    cpe_searchField = "vulnerable_product" if vulnProdSearch else "vulnerable_configuration"
    if lax:
        # get target version from product description provided by the user
        target_version = cpe.split(":")[-1]
        product = cpe.rsplit(":", 1)[0]
        # perform checks on the target version
        if None is target_version or [] is target_version:
            print("Error, target version not found at the end of product description '{}'".format(cpe))
            sys.exit(-1)
        for i in target_version.split("."):
            try:
                int(i)
            except:
                print(
                    "Error, target version should be of the form '1.2.3'. Current form is '{}'".format(target_version))
                sys.exit(-1)

        # over-approximate versions
        cpe_regex = product
        cves = Configuration.getMongoConnection().get_collection(Collections.CVE.value).find(
            {cpe_searchField: {"$regex": cpe_regex, '$options': 'i'}}).sort("Modified", -1)
        i = 0
        for cve in cves:
            vuln_confs = cve["vulnerable_configuration"]
            vuln_confs += cve["vulnerable_configuration_cpe_2_2"]
            vuln_confs += cve["vulnerable_product"]
            i += 1
            for vc in vuln_confs:
                if not cpe_regex in vc:
                    continue

                re_from_start = re.compile("^.*{}:".format(cpe_regex))
                cpe_version = re_from_start.sub("", vc)

                # TODO: handle versions such as "1.1.3:p2"
                cpe_version = cpe_version.split(":")[0]

                # TODO: handle versions such as "1.1.3p2"
                cpe_version = re.search("([0-9\.]*)", cpe_version).group(0)
                if len(cpe_version) is 0:
                    # TODO: print warnings
                    # print ("Warning, missing cpe version for {}: '{}'. Skipping cpe.".format(cve["id"], vc))
                    continue
                if target_version_is_included(target_version, cpe_version):
                    final_cves.append(cve)
                    break


    else:
        # default strict search
        cves = Configuration.getMongoConnection().get_collection(Collections.CVE.value).find(
            {cpe_searchField: {"$regex": cpe_regex, '$options': 'i'}})
        final_cves = cves

    final_cves = sanitize(final_cves)
    return {'results': final_cves, 'total': len(final_cves)}


# User Functions
@reconnect
def addUser(user, pwd, admin=False, localOnly=False):
    hashed = pbkdf2_sha256.encrypt(pwd, rounds=hash_rounds, salt_size=salt_size)
    entry = {'username': user, 'password': hashed}
    if admin:     entry['master'] = True
    if localOnly: entry['local_only'] = True
    Configuration.getMongoConnection().get_collection(Collections.Users.value).insert(entry)


@reconnect
def changePassword(user, pwd):
    hashed = pbkdf2_sha256.encrypt(pwd, rounds=hash_rounds, salt_size=salt_size)
    Configuration.getMongoConnection().get_collection(Collections.Users.value).update({'username': user},
                                                                                      {'$set': {'password': hashed}})


@reconnect
def verifyUser(user, pwd):
    person = getUser(user)
    return (person and pbkdf2_sha256.verify(pwd, person['password']))


@reconnect
def deleteUser(user):
    Configuration.getMongoConnection().get_collection(Collections.Users.value).remove({'username': user})


@reconnect
def setAdmin(user, admin=True):
    if admin:
        Configuration.getMongoConnection().get_collection(Collections.Users.value).update({'username': user},
                                                                                          {'$set': {'master': True}})
    else:
        Configuration.getMongoConnection().get_collection(Collections.Users.value).update({'username': user},
                                                                                          {'$unset': {'master': ""}})


@reconnect
def setLocalOnly(user, localOnly=True):
    if localOnly:
        Configuration.getMongoConnection().get_collection(Collections.Users.value).update({'username': user},
                                                                                          {'$set': {
                                                                                              'local_only': True}})
    else:
        Configuration.getMongoConnection().get_collection(Collections.Users.value).update({'username': user},
                                                                                          {'$unset': {
                                                                                              'local_only': ""}})


@reconnect
def isMasterAccount(user):
    return False if Configuration.getMongoConnection().get_collection(Collections.Users.value).find(
        {"username": user, "master": True}).count() == 0 else True


@reconnect
def userExists(user):
    return True if Configuration.getMongoConnection().get_collection(Collections.Users.value).find(
        {"username": user}).count() > 0 else False


@reconnect
def isSingleMaster(user):
    return True if len(list(Configuration.getMongoConnection().get_collection(Collections.Users.value).find(
        {"username": {"$ne": user}, "master": True}))) == 0 else False
    # jdt_NOTE: consider using built in count() of the mongo cursor as in previous functions
    # return True if colUSERS.find({'username': {'$ne': user}, 'master': True}).count() == 0 else False


# Query Functions
# Generic data
@reconnect
def getCVEs(limit=False, query=[], skip=0, cves=None, collection=None):
    col = Configuration.getMongoConnection().get_collection(
        Collections.CVE.value) if not collection else Configuration.getMongoConnection().get_collection(collection)
    if type(query) == dict: query = [query]
    if type(cves) == list: query.append({"id": {"$in": cves}})
    if len(query) == 0:
        cve = col.find().sort("Modified", -1).limit(limit).skip(skip)
    elif len(query) == 1:
        cve = col.find(query[0]).sort("Modified", -1).limit(limit).skip(skip)
    else:
        cve = col.find({"$and": query}).sort("Modified", -1).limit(limit).skip(skip)
    return {'results': sanitize(cve), 'total': cve.count()}

@reconnect
def getCVEsNewerThan(dt):
    return getCVEs(query={'last-modified': {'$gt': dt}})


@reconnect
def getCVEIDs(limit=-1):
    return [x["id"] for x in
            Configuration.getMongoConnection().get_collection(Collections.CVE.value).find().limit(limit).sort(
                "Modified", -1)]


@reconnect
def getCVE(id, collection=None):
    col = Configuration.getMongoConnection().get_collection(
        Collections.CVE.value) if not collection else Configuration.getMongoConnection().get_collection(collection)
    return sanitize(col.find_one({"id": id}))


@reconnect
def getCPE(id):
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.CPE.value).find_one({"id": id}))


@reconnect
def getCPEVersionInformation(query):
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.CPE.value).find_one(query))


@reconnect
def getCPEs():
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.CPE.value).find())


@reconnect
def getAlternativeCPE(id):
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.CPEOther.value).find_one({"id": id}))


@reconnect
def getAlternativeCPEs():
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.CPEOther.value).find())


@reconnect
def getVIA4(id):
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.VIA4.value).find_one({'id': id}))


@reconnect
def getCPEMatching(regex, fullSearch=False):
    lst = list(Configuration.getMongoConnection().get_collection(Collections.CPE.value).find(
        {"id": {"$regex": regex, '$options': 'i'}}))
    if fullSearch: lst.extend(Configuration.getMongoConnection().get_collection(Collections.CPEOther.value).find(
        {"id": {"$regex": regex, '$options': 'i'}}))
    return lst


@reconnect
def getFreeText(text):
    try:  # Before Mongo 3
        return [x["obj"] for x in Configuration.getMongoConnection().command("text", "cves", search=text)["results"]]
    except:  # As of Mongo 3
        return sanitize(
            Configuration.getMongoConnection().get_collection(Collections.CVE.value).find({"$text": {"$search": text}}))


@reconnect
def getSearchResults(search):
    result = {'data': []}
    regSearch = re.compile(re.escape(search), re.I)
    links = {'n': 'Link', 'd': []}
    for vLink in getInfo('via4').get('searchables', []):
        links['d'].extend(sanitize(
            Configuration.getMongoConnection().get_collection(Collections.VIA4.value).find(
                {vLink: {'$in': [regSearch]}})))

    try:
        textsearch = {'n': 'Text search', 'd': getFreeText(search)}
    except:
        textsearch = {'n': 'Text search', 'd': []}
        result['errors'] = ['textsearch']

    for collection in [links, textsearch]:
        for item in collection['d']:
            # Check if already in result data
            if not any(item['id'] == entry['id'] for entry in result['data']):
                entry = getCVE(item['id'])
                if entry:
                    entry['reason'] = collection['n']
                    result['data'].append(entry)
    return result


@reconnect
def getCAPECFor(cwe):
    return sanitize(
        Configuration.getMongoConnection().get_collection(Collections.CAPEC.value).find(
            {'related_weakness': {'$in': [cwe]}}))


@reconnect
def getCAPEC(cweid):
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.CAPEC.value).find_one({'id': cweid}))


@reconnect
def getCWEs():
    return sanitize(
        sorted(Configuration.getMongoConnection().get_collection(Collections.CWE.value).find(),
               key=lambda k: int(k['id'])))


@reconnect
def getInfo(collection):
    return sanitize(
        Configuration.getMongoConnection().get_collection(Collections.Info.value).find_one({"db": collection}))


@reconnect
def getLastModified(collection):
    info = getInfo(collection)
    return info['last-modified'] if info else None


@reconnect
def getSize(collection):
    return Configuration.getMongoConnection().get_collection(collection).count()


@reconnect
def via4Linked(key, val):
    cveList = [x['id'] for x in
               Configuration.getMongoConnection().get_collection(Collections.VIA4.value).find({key: val})]
    return sanitize(getCVEs(query={'id': {'$in': cveList}}))


@reconnect
def getDBStats(include_admin=False):
    data = {'cves': {}, 'cpe': {}, 'cpeOther': {}, 'capec': {}, 'cwe': {}, 'via4': {}}
    for key in data.keys():
        data[key] = {'size': getSize(key.lower()),
                     'last_update': getLastModified(key.lower())}
    if include_admin:
        data['whitelist'] = {
            'size': Configuration.getMongoConnection().get_collection(Collections.WhiteList.value).count()}
        data['blacklist'] = {
            'size': Configuration.getMongoConnection().get_collection(Collections.BlackList.value).count()}
        data = {'stats': {'size_on_disk': Configuration.getMongoConnection().command("dbstats")['storageSize'],
                          'db_size': Configuration.getMongoConnection().command('dbstats')['dataSize'],
                          'name': Configuration.getMongoDB()},
                'data': data}
    return data


# Dynamic data
@reconnect
def getWhitelist():
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.WhiteList.value).find())


@reconnect
def isInWhitelist(cpe):
    return True if Configuration.getMongoConnection().get_collection(Collections.WhiteList.value).find(
        {'id': cpe}).count() > 0 else False


@reconnect
def addToWhitelist(cpe, type, comments=None):
    if comments:
        Configuration.getMongoConnection().get_collection(Collections.WhiteList.value).insert(
            {'id': cpe, 'type': type, 'comments': comments})
    else:
        Configuration.getMongoConnection().get_collection(Collections.WhiteList.value).insert({'id': cpe, 'type': type})


@reconnect
def removeFromWhitelist(cpe):
    Configuration.getMongoConnection().get_collection(Collections.WhiteList.value).remove({'id': cpe})


@reconnect
def updateWhitelist(oldCPE, newCPE, type, comments=None):
    if comments:
        Configuration.getMongoConnection().get_collection(Collections.WhiteList.value).update({'id': oldCPE},
                                                                                              {'id': newCPE,
                                                                                               'type': type,
                                                                                               'comments': comments})
    else:
        Configuration.getMongoConnection().get_collection(Collections.WhiteList.value).update({'id': oldCPE},
                                                                                              {'id': newCPE,
                                                                                               'type': type})


@reconnect
def getBlacklist():
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.BlackList.value).find())


@reconnect
def isInBlacklist(cpe):
    return True if Configuration.getMongoConnection().get_collection(Collections.BlackList.value).find(
        {'id': cpe}).count() > 0 else False


@reconnect
def addToBlacklist(cpe, type, comments=None):
    if comments:
        Configuration.getMongoConnection().get_collection(Collections.BlackList.value).insert(
            {'id': cpe, 'type': type, 'comments': comments})
    else:
        Configuration.getMongoConnection().get_collection(Collections.BlackList.value).insert({'id': cpe, 'type': type})


@reconnect
def removeFromBlacklist(cpe):
    Configuration.getMongoConnection().get_collection(Collections.BlackList.value).remove({'id': cpe})


@reconnect
def updateBlacklist(oldCPE, newCPE, type, comments=None):
    if comments:
        Configuration.getMongoConnection().get_collection(Collections.BlackList.value).update({'id': oldCPE},
                                                                                              {'id': newCPE,
                                                                                               'type': type,
                                                                                               'comments': comments})
    else:
        Configuration.getMongoConnection().get_collection(Collections.BlackList.value).update({'id': oldCPE},
                                                                                              {'id': newCPE,
                                                                                               'type': type})


@reconnect
def getRules(list):
    if list.lower() == 'whitelist':
        col = Configuration.getMongoConnection().get_collection(Collections.WhiteList.value)
    elif list.lower() == 'blacklist':
        col = Configuration.getMongoConnection().get_collection(Collections.BlackList.value)
    else:
        return []
    rlist = col.find({'type': 'cpe'}).distinct('id')
    rlist.extend(["cpe:2.3:([^:]*:){9}" + re.escape(x) for x in col.find({'type': 'targethardware'}).distinct('id')])
    rlist.extend(["cpe:2.3:([^:]*:){8}" + re.escape(x) for x in col.find({'type': 'targetsoftware'}).distinct('id')])
    return rlist


@reconnect
def addRanking(cpe, key, rank):
    item = findRanking(cpe)
    if item is None:
        Configuration.getMongoConnection().get_collection(Collections.Ranking.value).update({'cpe': cpe},
                                                                                            {"$push": {
                                                                                                'rank': {key: rank}}},
                                                                                            upsert=True)
    else:
        l = []
        for i in item['rank']:
            i[key] = rank
            l.append(i)
        Configuration.getMongoConnection().get_collection(Collections.Ranking.value).update({'cpe': cpe},
                                                                                            {"$set": {'rank': l}})
    return True


@reconnect
def removeRanking(cpe):
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.Ranking.value).remove(
        {'cpe': {'$regex': cpe, '$options': 'i'}}))


@reconnect
def findRanking(cpe=None, regex=False):
    if not cpe:
        # return sanitize(colRANKING.find())
        return None
    if regex:
        # return sanitize(colRANKING.find_one({'cpe': {'$regex': cpe}}))
        return None
    else:
        return None
        # return sanitize(colRANKING.find_one({'cpe': cpe}))


# Users
@reconnect
def getUsers():
    return sanitize(Configuration.getMongoConnection().get_collection(Collections.Users.value).find())


@reconnect
def getUser(user):
    return sanitize(
        Configuration.getMongoConnection().get_collection(Collections.Users.value).find_one({"username": user}))


@reconnect
def getToken(user):
    data = sanitize(
        Configuration.getMongoConnection().get_collection(Collections.Users.value).find_one({"username": user}))
    if not data:              return None
    if 'token' in data.keys():
        return data['token']
    else:
        return generateToken(user)


@reconnect
def generateToken(user):
    token = uuid.uuid4().hex
    Configuration.getMongoConnection().get_collection(Collections.Users.value).update({'username': user},
                                                                                      {'$set': {'token': token}})
    return token


###########
# Plugins #
###########
# Settings
@reconnect
def p_writeSetting(plugin, setting, value):
    Configuration.getMongoConnection().get_collection(Collections.PluginSettings.value).update({"plugin": plugin},
                                                                                               {"$set": {
                                                                                                   setting: value}},
                                                                                               upsert=True)


@reconnect
def p_readSetting(plugin, setting):
    data = list(
        Configuration.getMongoConnection().get_collection(Collections.PluginSettings.value).find({'plugin': plugin},
                                                                                                 {setting: 1}).distinct(
            setting))
    if len(data) != 0:
        data = data[0]
        return data
    return None


@reconnect
def p_deleteSettings(plugin):
    Configuration.getMongoConnection().get_collection(Collections.PluginSettings.value).remove({"plugin": plugin})


@reconnect
def p_writeUserSetting(plugin, user, setting, value):
    Configuration.getMongoConnection().get_collection(Collections.PluginSettings.value).update(
        {"plugin": plugin, "user": user},
        {"$set": {setting: value}},
        upsert=True)


@reconnect
def p_readUserSetting(plugin, user, setting):
    data = list(Configuration.getMongoConnection().get_collection(Collections.PluginSettings.value).find(
        {'plugin': plugin, 'user': user}, {setting: 1}).distinct(setting))
    if len(data) != 0:
        data = data[0]
        return data
    return None


@reconnect
def p_deleteUserSettings(plugin):
    Configuration.getMongoConnection().get_collection(Collections.PluginSettings.value).remove({"plugin": plugin})


# Query
@reconnect
def p_queryData(collection, query):
    return sanitize(Configuration.getMongoConnection().get_collection('plug_%s' % collection).find(query))


@reconnect
def p_queryOne(collection, query):
    data = sanitize(Configuration.getMongoConnection().get_collection('plug_%s' % collection).find_one(query))
    return data if data else []  # Compatibility between several Flask-PyMongo versions


# Data manipulation
@reconnect
def p_drop(col):
    Configuration.getMongoConnection().get_collection('plug_%s' % col).drop()


@reconnect
def p_addEntry(collection, data):
    Configuration.getMongoConnection().get_collection('plug_%s' % collection).insert(data)


@reconnect
def p_removeEntry(collection, query):
    Configuration.getMongoConnection().get_collection('plug_%s' % collection).remove(query)


@reconnect
def p_bulkUpdate(collection, keyword, data):
    if type(data) is not list: data = [data]
    if len(data) > 0:
        bulk = Configuration.getMongoConnection().get_collection('plug_%s' % collection).initialize_ordered_bulk_op()
        for x in data:
            bulk.find({keyword: x[keyword]}).upsert().update({'$set': x})
        bulk.execute()


@reconnect
def p_addToList(collection, query, listname, data):
    if type(data) != list: data = [data]
    current = list(p_queryData(collection, query))
    if len(current) == 0:
        p_addEntry(collection, query)
    for entry in current:
        if listname in entry:
            data = list(set([repr(x) for x in data]) - set([repr(x) for x in entry[listname]]))
            data = [ast.literal_eval(x) for x in data]
        if data:
            Configuration.getMongoConnection().get_collection('plug_%s' % collection).update(query, {
                "$addToSet": {listname: {"$each": data}}})


@reconnect
def p_removeFromList(collection, query, listname, data):
    if type(data) == dict:
        Configuration.getMongoConnection().get_collection('plug_%s' % collection).update(query,
                                                                                         {"$pull": {listname: data}})
    elif type(data) != list:
        data = [data]
    Configuration.getMongoConnection().get_collection('plug_%s' % collection).update(query,
                                                                                     {"$pullAll": {listname: data}})
