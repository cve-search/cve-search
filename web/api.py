#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# API module of cve-search. Returns queries in JSON format
#
# Software is free software released under the "Modified BSD license"
#

# Copyright (c) 2013-2016 	Alexandre Dulaunoy - a@foo.be
# Copyright (c) 2014-2016 	Pieter-Jan Moreels - pieterjan.moreels@gmail.com

# imports
import json
import logging
import os
import random
import signal
import sys
import time
import urllib
_runPath = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(_runPath, ".."))

from bson               import json_util
from flask              import Flask, jsonify, request
from functools          import wraps
from logging.handlers   import RotatingFileHandler
from tornado.httpserver import HTTPServer
from tornado.ioloop     import IOLoop
from tornado.wsgi       import WSGIContainer

import lib.CVEs          as cves
import lib.DatabaseLayer as db
import lib.Query         as query
import lib.Toolkit       as tk

from lib.Config import Configuration

class API():
  app = Flask(__name__, static_folder='static', static_url_path='/static')
  app.config['MONGO_DBNAME'] = Configuration.getMongoDB()
  app.config['SECRET_KEY'] = str(random.getrandbits(256))

  def __init__(self):
    routes = [{'r': '/api/cpe2.3/<path:cpe>',              'm': ['GET'], 'f': self.api_cpe23},
              {'r': '/api/cpe2.2/<path:cpe>',              'm': ['GET'], 'f': self.api_cpe22},
              {'r': '/api/cvefor/<path:cpe>',              'm': ['GET'], 'f': self.api_cvesFor},
              {'r': '/api/cve/<cveid>',                    'm': ['GET'], 'f': self.api_cve},
              {'r': '/api/last',                           'm': ['GET'], 'f': self.api_last},
              {'r': '/api/last/',                          'm': ['GET'], 'f': self.api_last},
              {'r': '/api/last/<int:limit>',               'm': ['GET'], 'f': self.api_last},
              {'r': '/api/browse',                         'm': ['GET'], 'f': self.api_browse},
              {'r': '/api/browse/',                        'm': ['GET'], 'f': self.api_browse},
              {'r': '/api/browse/<vendor>',                'm': ['GET'], 'f': self.api_browse},
              {'r': '/api/search/<vendor>/<path:product>', 'm': ['GET'], 'f': self.api_search},
              {'r': '/api/dbInfo',                         'm': ['GET'], 'f': self.api_dbInfo}]
    for route in routes: self.addRoute(route)

  def addRoute(self, route):
    self.app.add_url_rule(route['r'], view_func=route['f'], methods=route['m'])

  #############
  # Decorator #
  #############
  def api(funct):
    @wraps(funct)
    def api_wrapper(*args, **kwargs):
      data = funct(*args, **kwargs)
      try:
        if request.url_rule and type(data) in [dict, list]:
            data = json.dumps(data, default=json_util.default)
        return data
      except:
        return data
    return api_wrapper

  ##########
  # ROUTES #
  ##########
  # /api/cpe2.3/<cpe>
  def api_cpe23(self, cpe):
    cpe = tk.toStringFormattedCPE(cpe)
    return cpe if cpe else "None"

  # /api/cpe2.2/<cpe>
  def api_cpe22(self, cpe):
    cpe = tk.toOldCPE(cpe)
    return cpe if cpe else "None"

  # /api/cvefor/<cpe>
  @api
  def api_cvesFor(self, cpe):
    cpe  = urllib.parse.unquote_plus(cpe)
    cves = query.cvesForCPE(cpe)
    return cves

  # /api/cve/<cveid>
  @api
  def api_cve(self, cveid):
    cvesp = cves.last(rankinglookup=True, namelookup=True, via4lookup=True, capeclookup=True)
    cve = cvesp.getcve(cveid=cveid.upper())
    if cve is None: cve = {}
    return cve

  # /api/last
  # /api/last/
  # /api/last/<limit>
  @api
  def api_last(self, limit=None):
    limit = limit if limit else 30
    cvesp = cves.last(rankinglookup=True, namelookup=True, via4lookup=True, capeclookup=True)
    cve = cvesp.get(limit=limit)
    return cve

  # /api/browse
  # /api/browse/
  # /api/browse/<vendor>
  @api
  def api_browse(self, vendor=None):
    if vendor:
      vendor = urllib.parse.quote_plus(vendor).lower()
    browseList = query.getBrowseList(vendor)
    if isinstance(browseList, dict):
      return browseList
    else:
      return {}

  # /api/search/<vendor>/<path:product>
  @api
  def api_search(self, vendor=None, product=None):
    if vendor is None or product is None: return jsonify({})
    search = vendor + ":" + product
    # Not using query.cvesForCPE, because that one gives too much info
    #return json.dumps(db.cvesForCPE(search), default=json_util.default)
    return db.cvesForCPE(search)


  # /api/dbInfo
  @api
  def api_dbInfo(self):
    return db.getDBStats()


  ########################
  # Web Server Functions #
  ########################
  # signal handlers
  def sig_handler(self, sig, frame):
    print('Caught signal: %s' % sig)
    IOLoop.instance().add_callback(self.shutdown)

  def shutdown(self):
    MAX_WAIT_SECONDS_BEFORE_SHUTDOWN = 3
    print('Stopping http server')
    self.http_server.stop()

    print('Will shutdown in %s seconds ...' % MAX_WAIT_SECONDS_BEFORE_SHUTDOWN)
    io_loop = IOLoop.instance()
    deadline = time.time() + MAX_WAIT_SECONDS_BEFORE_SHUTDOWN

    def stop_loop():
      now = time.time()
      if now < deadline and (io_loop._callbacks or io_loop._timeouts):
        io_loop.add_timeout(now + 1, stop_loop)
      else:
        io_loop.stop()
        print('Shutdown')
    stop_loop()

  def start(self):
    # get properties
    flaskHost = Configuration.getFlaskHost()
    flaskPort = Configuration.getFlaskPort()
    flaskDebug = Configuration.getFlaskDebug()
    # logging
    if Configuration.getLogging():
      logfile = Configuration.getLogfile()
      pathToLog = logfile.rsplit('/', 1)[0]
      if not os.path.exists(pathToLog):
        os.makedirs(pathToLog)
      maxLogSize = Configuration.getMaxLogSize()
      backlog = Configuration.getBacklog()
      file_handler = RotatingFileHandler(logfile, maxBytes=maxLogSize, backupCount=backlog)
      file_handler.setLevel(logging.ERROR)
      formatter = logging.Formatter("%(asctime)s - %(name)s - %(levelname)s - %(message)s")
      file_handler.setFormatter(formatter)
      self.app.logger.addHandler(file_handler)

    if flaskDebug:
      # start debug flask server
      self.app.run(host=flaskHost, port=flaskPort, debug=flaskDebug)
    else:
      # start asynchronous server using tornado wrapper for flask
      # ssl connection
      print("Server starting...")
      if Configuration.useSSL():
        ssl_options = {"certfile": os.path.join(_runPath, "../", Configuration.getSSLCert()),
                        "keyfile": os.path.join(_runPath, "../", Configuration.getSSLKey())}
      else:
        ssl_options = None
      signal.signal(signal.SIGTERM, self.sig_handler)
      signal.signal(signal.SIGINT,  self.sig_handler)

      self.http_server = HTTPServer(WSGIContainer(self.app), ssl_options=ssl_options)
      self.http_server.bind(flaskPort, address=flaskHost)
      self.http_server.start(0)  # Forks multiple sub-processes
      IOLoop.instance().start()


if __name__ == '__main__':
  server = API()
  server.start()
