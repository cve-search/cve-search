#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Manager for the database
#
# Software is free software released under the "GNU Affero General Public License v3.0"
#
# Copyright (c) 2012 		Wim Remes
# Copyright (c) 2012-2018 	Alexandre Dulaunoy - a@foo.be
# Copyright (c) 2014-2018 	Pieter-Jan Moreels - pieterjan.moreels@gmail.com

# Imports
# make sure these modules are available on your system
import os
import sys
runPath = os.path.dirname(os.path.realpath(__file__))
sys.path.append(os.path.join(runPath, ".."))
import re
import argparse
import datetime
import json
from xml.sax import make_parser
from xml.sax.handler import ContentHandler
from urllib.parse import quote, unquote
from cpe import CPE
from dateutil.parser import parse as parse_datetime
import os
import gzip
from lib.ProgressBar import progressbar
from lib.Toolkit import toStringFormattedCPE
from lib.Config import Configuration
import lib.DatabaseLayer as db
import operator
import logging


local_data_folder = os.path.join(os.path.dirname(__file__), '..', 'data')
if os.path.isdir(local_data_folder) is False:
    os.mkdir(local_data_folder)
log_file = os.path.join(local_data_folder, 'error_log_'+str(datetime.datetime.strftime(datetime.datetime.now(),
                                                                                       "%Y-%m-%d-%H-%M-%S")))
# print(log_file)
logging.basicConfig(filename=log_file, level=logging.DEBUG, format='%(asctime)s %(levelname)s %(name)s %(message)s')

LOGGER=logging.getLogger(__name__)

# init parts of the file names to enable looped file download
xml_file_prefix = "nvdcve-2.0-"
xml_file_suffix = ".xml.gz"
json_file_prefix = "nvdcve-1.0-"
json_file_suffix = ".json.gz"

file_mod = "modified"
file_rec = "recent"
software_versions_json = 'software_versions.json'

# get the current year. This enables us to download all CVE's up to this year :-)
date = datetime.datetime.now()
year = date.year + 1

# default config
defaultvalue = {}
defaultvalue['cwe'] = "Unknown"

cveStartYear = Configuration.getCVEStartYear()

# define the CVE parser. Thanks to Meredith Patterson (@maradydd) for help on this one.

class CVESJsonParser():
    def __init__(self):
        self.cves = []
        self.current_cve = ''

    def parse(self, cves_file):
        # json.loads(f.read().decode("ascii"))
        cves_data = json.loads(cves_file.read().decode('utf-8'))['CVE_Items']
        # cves_data = json.loads(cves_file.read())['CVE_Items']
        for cve in cves_data:
            self.cves.append(self.parse_cve(cve))

    def parse_cve(self, cve):
        parsed_cve = {}

        parsed_cve['id'] = cve['cve']['CVE_data_meta']['ID']
        self.current_cve = parsed_cve['id']
        if self.current_cve == 'CVE-2010-2127':
            print('crap')

        parsed_cve['references'] = [ref['url'] for ref in cve['cve']['references']['reference_data']]
        parsed_cve['vulnerable_configuration'] = self.get_vulnerable_configuration(cve['configurations']['nodes'])

        parsed_cve['vulnerable_configuration_cpe_2_2'] = [configuration.replace('cpe:2.3:', 'cpe:/', 1)
                                                          for configuration in parsed_cve['vulnerable_configuration']]
        try:
            cpe_class = parsed_cve['vulnerable_configuration'][0].split(':')[2]
        except IndexError:
            cpe_class = ''
        parsed_cve['vulnerable_product'] = self.get_vulnerable_product(cve['cve']['affects'], cpe_class)

        try:
            parsed_cve['cwe'] = self.get_cwe(cve['cve']['problemtype'])
        except (KeyError, IndexError):
            pass
        try:
            parsed_cve['cvss'] = cve['impact']['baseMetricV2']['cvssV2']['baseScore']
            parsed_cve['access'] = self.get_access(cve['impact'])
            parsed_cve['impact'] = self.get_impact(cve['impact'])
            parsed_cve['raw_impact'] = cve['impact']
        except KeyError:
            pass

        parsed_cve['summary'] = cve['cve']['description']['description_data'][0]['value']
        parsed_cve['Published'] = parse_datetime(cve['publishedDate'], ignoretz=True)
        parsed_cve['Modified'] = parse_datetime(cve['lastModifiedDate'], ignoretz=True)

        return parsed_cve

    def get_impact(self, impact):
        return {'confidentiality': impact['baseMetricV2']['cvssV2']['confidentialityImpact'],
                'integrity': impact['baseMetricV2']['cvssV2']['integrityImpact'],
                'availability': impact['baseMetricV2']['cvssV2']['availabilityImpact']
                }

    def get_access(self, impact):
        return {'vector': impact['baseMetricV2']['cvssV2']['accessVector'],
                'complexity': impact['baseMetricV2']['cvssV2']['accessComplexity'],
                'authentication': impact['baseMetricV2']['cvssV2']['authentication']}


    def get_cwe(self, problem_type):
        return problem_type['problemtype_data'][0]['description'][0]['value']


    def get_vulnerable_product(self, vendor, cpe_class):
        vulnerable_products = []
        vendors = vendor['vendor']['vendor_data']
        for vendor in vendors:
            vendor_name = vendor['vendor_name']
            products = vendor['product']['product_data']
            for product in products:
                product_name = product['product_name']
                versions = product['version']['version_data']
                for version in versions:
                    version_value = version['version_value']

                    vulnerable_products.append('{vendor_part}:{product_part}:{version_part}'.format(
                        vendor_part=CVESJsonParser.encode_string(vendor_name),
                        product_part=CVESJsonParser.encode_string(product_name),
                        version_part="" if version_value == "*" else ":"+CVESJsonParser.encode_string(version_value)
                    ))

                        # f'{CVESJsonParser.encode_string(vendor_name)}'
                        #                        f':{CVESJsonParser.encode_string(product_name)}'
                        #                        f'{"" if version_value == "*" else ":"+CVESJsonParser.encode_string(version_value)}')
        return vulnerable_products

    @staticmethod
    def encode_string(str_input):
        str_output = ''
        for letter in str_input:
            if letter.isalnum():
                str_output += letter
            elif letter == '/':
                str_output += '%2f'
            else:
                str_output += quote(letter).lower()

        return str_output


    def get_vulnerable_configuration(self, configurations):
        vulnerable_configurations = []
        for configuration in configurations:
            try:
                children = configuration['children']
                vulnerable_configurations.extend(self.get_vulnerable_configuration(children))
            except KeyError:
                try:
                    for cpe in configuration['cpe_match']:
                        vulnerable_configurations.extend(self.enumerate_versions(cpe))
                except MissingSoftwareVendorProductError as missing_vendor_error:
                    LOGGER.error('Missing software: {missing_vendor_error}'.format(
                        missing_vendor_error=missing_vendor_error))
                    # LOGGER.error(f'Missing software: {missing_vendor_error}')
                except NotImplementedError as not_implemented:
                    LOGGER.error('NotImplementedError: {not_implemented}'.format(
                        not_implemented=not_implemented))
                    # LOGGER.error(f'NotImplementedError: {not_implemented}')
                except KeyError as key_error:
                    LOGGER.error('CPE Match not found, {current_cve}, {key_error}'.format(
                        current_cve=self.current_cve,
                        key_error=key_error
                    ))
                    # LOGGER.error(f'CPE Match not found, {self.current_cve}, {key_error}')



        return vulnerable_configurations

    def get_count_of_non_significant_zeroes(self, input):

        original_length = len(input)
        without_non_signifcant_zeroes_length = len(str(int(input)))
        return original_length - without_non_signifcant_zeroes_length




    def sort_list_of_versions(self, list_of_versions):
        to_sort_dictionary_of_versions = {}
        map_of_alpha_part_of_version = defaultdict(list)

        list_of_alpha_versions = []

        for version in list_of_versions:
            # TODO: empty version is an option, right now it is taken care off outside of this funciton
            # TODO: but it should be brought into this function

            regex_obj = re.search('^[0-9]+(\.[0-9]+)*', version)
            if regex_obj:
                number_part_of_version = regex_obj.group(0)
                alpha_part_of_version = version[regex_obj.end():]
            else:
                number_part_of_version = version
                alpha_part_of_version = ''

            try:
                if number_part_of_version not in map_of_alpha_part_of_version:
                        to_sort_dictionary_of_versions[number_part_of_version] = list(map(int, number_part_of_version.split('.')))

                map_of_alpha_part_of_version[number_part_of_version].append(alpha_part_of_version)


            except ValueError as value_error:
                list_of_alpha_versions.append(version)



        sorted_list_of_broken_up_versions = sorted(to_sort_dictionary_of_versions.items(), key=operator.itemgetter(1))
        merged_sorted_list = []
        for version_string, _ in sorted_list_of_broken_up_versions:
            merged_version = version_string
            for extra_version_info in sorted(map_of_alpha_part_of_version[merged_version]):
                merged_sorted_list.append(merged_version if extra_version_info == ''
                                          else merged_version+extra_version_info)

        return merged_sorted_list + sorted(list_of_alpha_versions)



    def enumerate_versions(self, cpe_json):

        cpe_versions = []

        cpe_object = CPE(cpe_json['cpe23Uri'])

        product = cpe_object.get_product().pop()

        software_name = cpe_object.get_vendor().pop() + ':' + product

        if ('versionStartIncluding' in cpe_json or 'versionStartExcluding' in cpe_json) or \
                ('versionEndIncluding' in cpe_json or 'versionEndExcluding' in cpe_json):

            try:
                list_of_versions = all_software_version[software_name]
            except KeyError:
                raise MissingSoftwareVendorProductError('{software_name} not found in versions dictionary'.format(
                    software_name=software_name
                ))
            empty_version_removed = False

            try:
                list_of_versions[list_of_versions.index('')] = '0'
                empty_version_removed = True
            except ValueError:
                pass

            try:
                list_of_versions[list_of_versions.index('-')] = '0'
                hyphen_version_removed = True
            except ValueError:
                pass



            try:
                list_of_versions = self.sort_list_of_versions(list_of_versions)
                used_integer_sort = True
            except ValueError as value_error:
                list_of_versions = sorted(list_of_versions)
                used_integer_sort = False

            # if empty_version_removed:
            #     list_of_versions.insert(0, '')

            list_of_vulnerable_versions = []

            current_version_in_range = False
            for version in list_of_versions:
                if not current_version_in_range:
                    try:
                        if self.is_greater_than(version, cpe_json['versionStartIncluding'].replace('(', '\(').replace(')', '\)'),
                                                is_greater_than_equal=True, integer_sort=used_integer_sort):
                            current_version_in_range = True
                    except KeyError:
                        try:
                            if self.is_greater_than(version, cpe_json['versionStartExcluding'].replace('(', '\(').replace(')', '\)'),
                                                    is_greater_than_equal=False, integer_sort=used_integer_sort):
                                current_version_in_range = True
                        except KeyError:
                            # if both keys 'versionStartIncluding' and 'versionStartExcluding'
                            # are missing it means that all versions need to be included
                            # till the versionEnd(Including/Excluding) is applicable
                            current_version_in_range = True
                else:
                    try:
                        if self.is_greater_than(version, cpe_json['versionEndIncluding'].replace('(', '\(').replace(')', '\)'),
                                                is_greater_than_equal=False, integer_sort=used_integer_sort):
                            current_version_in_range = False
                    except KeyError:
                        try:
                            if self.is_greater_than(version, cpe_json['versionEndExcluding'].replace('(', '\(').replace(')', '\)'),
                                                    is_greater_than_equal=True, integer_sort=used_integer_sort):
                                current_version_in_range = False
                        except KeyError:
                            pass


                if current_version_in_range:
                    cpe_parts = ['cpe',
                                 cpe_object.VERSION,
                                 cpe_object.get_part().pop(),
                                 cpe_object.get_vendor().pop(),
                                 cpe_object.get_product().pop()
                                 ]
                    # ('o' if cpe_object.is_operating_system()
                    #  else ('h' if cpe_object.is_hardware()
                    #        else ('a' if cpe_object.is_application else '')))
                    if version != '' and version != '0':
                        # cpe_parts.append((unquote(version)).replace('(', '\\(').replace(')', '\\)').replace('!', '\\!'))
                        cpe_parts.append(version)

                    list_of_vulnerable_versions.append(':'.join(cpe_parts))
            cpe_versions.extend(list_of_vulnerable_versions)
        else:

            cpe_functions = ['get_other',
                             'get_target_hardware',
                             'get_target_software',
                             'get_software_edition',
                             'get_language',
                             'get_edition',
                             'get_update',
                             'get_version',
                             'get_product',
                             'get_vendor',
                             'get_part']
            cpe_string = ''
            attribute_found = False
            for cpe_function in cpe_functions:
                cpe_value = getattr(cpe_object, cpe_function)().pop()
                if cpe_value == '' or cpe_value == '*' or cpe_value == '-':
                    cpe_string = ('-:' + cpe_string if attribute_found else '')
                else:
                    cpe_string = cpe_value + ':' + cpe_string if attribute_found else cpe_value
                    attribute_found = True

            cpe_string = 'cpe:{cpe_object_version}:{cpe_string}'.format(
                cpe_object_version=cpe_object.VERSION,
                cpe_string=cpe_string
            )
            cpe_versions.append(cpe_string)

        return cpe_versions


    def is_greater_than(self, first_version, second_version, is_greater_than_equal, integer_sort):

        first_version_list = first_version
        second_version_list = second_version
        first_extra = ''
        second_extra = ''

        if integer_sort is True:
            try:
                first_version_without_extra = self.remove_trailing_letters(first_version.split(':')[0])
                second_version_without_extra = self.remove_trailing_letters(second_version.split(':')[0])

                first_extra = first_version.replace(first_version_without_extra, '')
                second_extra = second_version.replace(second_version_without_extra, '')

                first_version_list = list(map(int, first_version_without_extra.split('.')))
                second_version_list = list(map(int, second_version_without_extra.split('.')))
            except ValueError as value_error:
                first_version_list = first_version
                second_version_list = second_version


        try:
            if is_greater_than_equal is True:
                return first_version_list >= second_version_list and first_extra >= second_extra

            return first_version_list > second_version_list and first_extra > second_extra
        except TypeError as type_error:
            raise TypeError(type_error)


    def remove_trailing_letters(self, input):

        regex = re.search('^[0-9]+(\.[0-9]+)*', input)
        if regex:
            return regex.group(0)
        else:
            return input




class CVESIndividualObjectParser():
    @staticmethod
    def parse(cves_entry):
        pass


class MissingSoftwareVendorProductError(Exception):
    pass

class CPEDictionaryHandler(ContentHandler):
    def __init__(self):
        self.vendorProductVersions = defaultdict(set)
        self.inCPEItem = 0
        self.cpe_functions = ['get_other',
                              'get_target_hardware',
                              'get_target_software',
                              'get_software_edition',
                              'get_language',
                              'get_edition',
                              'get_update',
                              'get_version']

    def startElement(self, name, attrs):

        if name == 'cpe-23:cpe23-item':

            self.inCPEItem = 1
            self.cpe_uri = attrs['name']

    def endElement(self, name):
        if name == 'cpe-23:cpe23-item':
            self.inCPEItem = 0

            cpe_obj = CPE(self.cpe_uri)
            vendor_and_product = '{cpe_vendor}:{cpe_product}'.format(
                cpe_vendor=cpe_obj.get_vendor().pop(),
                cpe_product=cpe_obj.get_product().pop()
            )

            version_string = ''
            attribute_found = False
            for cpe_function in self.cpe_functions:
                cpe_value = getattr(cpe_obj, cpe_function)().pop()
                if cpe_value == '' or cpe_value == '-' or cpe_value == '*':
                    version_string = ('-:{version_string}'.format(
                        version_string=version_string
                    ) if attribute_found else '')
                else:
                    version_string = '{cpe_value}:{version_string}'.format(
                        cpe_value=cpe_value,
                        version_string=version_string
                    ) if attribute_found else cpe_value
                    attribute_found = True
            self.vendorProductVersions[vendor_and_product].add(version_string)


class CVEHandler(ContentHandler):
    def __init__(self):
        self.cves = []
        self.inCVSSElem = 0
        self.inSUMMElem = 0
        self.inDTElem = 0
        self.inVPElem = 0
        self.inPUBElem = 0
        self.inAccessvElem = 0
        self.inAccesscElem = 0
        self.inAccessaElem = 0
        self.inCVSSgenElem = 0
        self.inImpactiElem = 0
        self.inImpactcElem = 0
        self.inImpactaElem = 0

    def startElement(self, name, attrs):
        if name == 'entry':
            self.cves.append({'id': attrs.get('id'), 'references': [], 'vulnerable_configuration': [], 
                              'vulnerable_configuration_cpe_2_2':[], 'vulnerable_product':[] })
            self.ref = attrs.get('id')
        elif name == 'cpe-lang:fact-ref':
            self.cves[-1]['vulnerable_configuration'].append(toStringFormattedCPE(attrs.get('name')))
            self.cves[-1]['vulnerable_configuration_cpe_2_2'].append(attrs.get('name'))
        elif name=='vuln:product':
            self.inVPElem = 1
            self.VP = ""
        elif name == 'cvss:score':
            self.inCVSSElem = 1
            self.CVSS = ""
        elif name == 'cvss:access-vector':
            self.inAccessvElem = 1
            self.accessv = ""
        elif name == 'cvss:access-complexity':
            self.inAccesscElem = 1
            self.accessc = ""
        elif name == 'cvss:authentication':
            self.inAccessaElem = 1
            self.accessa = ""
        elif name == 'cvss:confidentiality-impact':
            self.inImpactcElem = 1
            self.impactc = ""
        elif name == 'cvss:integrity-impact':
            self.inImpactiElem = 1
            self.impacti = ""
        elif name == 'cvss:availability-impact':
            self.inImpactaElem = 1
            self.impacta = ""
        elif name == 'cvss:generated-on-datetime':
            self.inCVSSgenElem = 1
            self.cvssgen = ""
        elif name == 'vuln:summary':
            self.inSUMMElem = 1
            self.SUMM = ""
        elif name == 'vuln:published-datetime':
            self.inDTElem = 1
            self.DT = ""
        elif name == 'vuln:last-modified-datetime':
            self.inPUBElem = 1
            self.PUB = ""
        elif name == 'vuln:reference':
            self.cves[-1]['references'].append(attrs.get('href'))
        elif name == 'vuln:cwe':
            self.cves[-1]['cwe'] = attrs.get('id')

    def characters(self, ch):
        if self.inCVSSElem:
            self.CVSS += ch
        if self.inVPElem:
            self.VP += ch
        if self.inSUMMElem:
            self.SUMM += ch
        if self.inDTElem:
            self.DT += ch
        if self.inPUBElem:
            self.PUB += ch
        if self.inAccessvElem:
            self.accessv += ch
        if self.inAccesscElem:
            self.accessc += ch
        if self.inAccessaElem:
            self.accessa += ch
        if self.inCVSSgenElem:
            self.cvssgen += ch
        if self.inImpactiElem:
            self.impacti += ch
        if self.inImpactcElem:
            self.impactc += ch
        if self.inImpactaElem:
            self.impacta += ch

    def endElement(self, name):
        if name == 'cvss:score':
            self.inCVSSElem = 0
            self.cves[-1]['cvss'] = self.CVSS
        if name == 'vuln:product':
            self.inVPElem = 0
            self.cves[-1]['vulnerable_product'].append(self.VP) 
        if name == 'cvss:access-vector':
            self.inAccessvElem = 0
            if 'access' not in self.cves[-1]:
                self.cves[-1]['access'] = {}
            self.cves[-1]['access']['vector'] = self.accessv
        if name == 'cvss:access-complexity':
            self.inAccesscElem = 0
            if 'access' not in self.cves[-1]:
                self.cves[-1]['access'] = {}
            self.cves[-1]['access']['complexity'] = self.accessc
        if name == 'cvss:authentication':
            self.inAccessaElem = 0
            if 'access' not in self.cves[-1]:
                self.cves[-1]['access'] = {}
            self.cves[-1]['access']['authentication'] = self.accessa
        if name == 'cvss:confidentiality-impact':
            self.inImpactcElem = 0
            if 'impact' not in self.cves[-1]:
                self.cves[-1]['impact'] = {}
            self.cves[-1]['impact']['confidentiality'] = self.impactc
        if name == 'cvss:integrity-impact':
            self.inImpactiElem = 0
            if 'impact' not in self.cves[-1]:
                self.cves[-1]['impact'] = {}
            self.cves[-1]['impact']['integrity'] = self.impacti
        if name == 'cvss:availability-impact':
            self.inImpactaElem = 0
            if 'impact' not in self.cves[-1]:
                self.cves[-1]['impact'] = {}
            self.cves[-1]['impact']['availability'] = self.impacta
        if name == 'cvss:generated-on-datetime':
            self.inCVSSgenElem = 0
            self.cves[-1]['cvss-time'] = parse_datetime(self.cvssgen, ignoretz=True)
        if name == 'vuln:summary':
            self.inSUMMElem = 0
            self.cves[-1]['summary'] = self.SUMM
        if name == 'vuln:published-datetime':
            self.inDTElem = 0
            self.cves[-1]['Published'] = parse_datetime(self.DT, ignoretz=True)
        if name == 'vuln:last-modified-datetime':
            self.inPUBElem = 0
            self.cves[-1]['Modified'] = parse_datetime(self.PUB, ignoretz=True)

# def test_length(cves):
#
#     for cve in cves:
#         if cve['id'] == 'CVE-2007-0005':
#             print('lets pause')
#         try:
#             assert len(cve['vulnerable_configuration']) == len(cve['vulnerable_configuration_cpe_2_2'])
#         except AssertionError:
#             print(f'{cve["id"]} vulnerable_configuration not equal to vulnerable_configuration_cpe_2_2')
#
#         try:
#             assert len(cve['vulnerable_product']) == len(cve['vulnerable_configuration_cpe_2_2'])
#         except AssertionError:
#             print(f'{cve["id"]} vulnerable_product: {len(cve["vulnerable_product"])} not equal to '
#                   f'vulnerable_configuration_cpe_2_2: {len(cve["vulnerable_configuration_cpe_2_2"])}')

from collections import defaultdict
all_software_versions = defaultdict(set)


def fix_version(version_string):
    for index, letter in enumerate(version_string):
        if letter.isalpha():
            if not version_string[index - 1].isdigit():
                version_string = version_string[:index - 1] + ':' + version_string[index:]
            else:
                version_string = version_string[:index] + ':' + version_string[index:]
            break
    return version_string

def get_software_name_and_version(cpe_string):
    pieces = cpe_string.split(':')
    software_name = ''
    version = ''
    version_already_found = False
    for index in range(2,len(pieces)):
        if version_already_found:
            version += ':' + pieces[index]
        elif re.search("^[0-9]+(.[0-9]+)*", pieces[index]) is not None or pieces[index] == '-':
            version_already_found = True
            version = pieces[index] if pieces[index] != '-' else ''
            version = fix_version(version)
            try:
                test_version = version.split(':')
                list(map(int, test_version[0].split('.')))
            except ValueError:
                LOGGER.debug('conversion of {pieces_index} failed for cpe string: {cpe_string}, returned: {version}'.format(
                    pieces_index=pieces[index],
                    cpe_string=cpe_string,
                    version=version
                ))
            # version = version.replace('_', ':', 1)
            # version = version.replace('-', ':', 1)
        else:
            software_name += pieces[index] if software_name == '' else ':' + pieces[index]
    if '-' in version:
        pass
    if '-' in software_name:
        pass
    return (software_name, version)

def populated_all_software_versions(cves):
    cpe_functions = ['get_other',
                     'get_target_hardware',
                     'get_target_software',
                     'get_software_edition',
                     'get_language',
                     'get_edition',
                     'get_update',
                     'get_version']

    for cve in cves:

        for configuration_cpe_uri in cve['vulnerable_configuration_cpe_2_2']:
            configuration_cpe = CPE(configuration_cpe_uri)
            vendor_and_product = configuration_cpe.get_vendor().pop() + ':' + configuration_cpe.get_product().pop()
            version_string = ''
            attribute_found = False
            for cpe_function in cpe_functions:
                cpe_value = getattr(configuration_cpe, cpe_function)().pop()
                if cpe_value == '' or cpe_value == '-':

                    version_string = ('-:'+version_string if attribute_found else '')
                else:
                    version_string = cpe_value + ':' + version_string if attribute_found else cpe_value
                    attribute_found = True
            all_software_versions[vendor_and_product].add(version_string)


def create_map_of_software_versions():
    cpe_dictionary_parser = make_parser()
    cpe_handler = CPEDictionaryHandler()
    cpe_dictionary_parser.setContentHandler(cpe_handler)

    try:
        print('Downloading CPE dictionary file')
        (f, r) = Configuration.getFile(Configuration.getFeedURL('cpe23'))
    except:
        sys.exit("Cannot open url %s. Bad URL or not connected to the internet?" % (
                    Configuration.getFeedURL('cve') + getfile))
    # with open(os.path.join(os.path.dirname(__file__), '../data/official-cpe-dictionary_v2.3.xml')) as f:
    print('Processing CPE dictionary file')
    cpe_dictionary_parser.parse(f)
    all_software_versions = cpe_handler.vendorProductVersions

    software_versions = open(os.path.join(local_data_folder, software_versions_json), 'w')

    for key in all_software_versions:
        all_software_versions[key] = list(all_software_versions[key])
    json.dump(all_software_versions, software_versions)

try:
    data_file_software_versions = open(os.path.join(local_data_folder, software_versions_json))
except FileNotFoundError:
    print('vendor product version map not available')
    create_map_of_software_versions()
    data_file_software_versions = open(os.path.join(local_data_folder, software_versions_json))



all_software_version = json.load(data_file_software_versions)


if __name__ == '__main__':

    # parse command line arguments
    argparser = argparse.ArgumentParser(description='populate/update the local CVE database')
    argparser.add_argument('-u', action='store_true', help='update the database')
    argparser.add_argument('-x', action='store_true', help='populate the database with xml files')
    argparser.add_argument('-j', action='store_true', help='populate the database with json files')
    argparser.add_argument('-a', action='store_true', default=False, help='force populating the CVE database')
    argparser.add_argument('-f', help='process a local xml file')
    argparser.add_argument('-v', action='store_true', help='verbose output')
    argparser.add_argument('-s', action='store_true', help='setup versions list for future enumeration')
    args = argparser.parse_args()

    parser = make_parser()
    ch = CVEHandler()
    parser.setContentHandler(ch)
    # start here if it's an update.
    if args.u:
        # get the 'modified' file
        getfile = xml_file_prefix + file_mod + xml_file_suffix
        try:
            (f, r) = Configuration.getFile(Configuration.getFeedURL('cve_xml') + getfile)
        except:
            sys.exit("Cannot open url %s. Bad URL or not connected to the internet?"%(Configuration.getFeedURL("cve") + getfile))
        i = db.getInfo("cves")
        last_modified = parse_datetime(r.headers['last-modified'], ignoretz=True)
        if i is not None:
            if last_modified == i['last-modified']:
                print("Not modified")
                sys.exit(0)
        db.setColUpdate("cves", last_modified)

        # get your parser on !!
        parser = make_parser()
        ch = CVEHandler()
        parser.setContentHandler(ch)
        parser.parse(f)
        for item in ch.cves:
            # check if the CVE already exists.
            x = db.getCVE(item['id'])
            # if so, update the entry.
            if x:
                if 'cvss' not in item:
                    item['cvss'] = None
                if 'cwe' not in item:
                    item['cwe'] = defaultvalue['cwe']
                db.updateCVE(item)
            else:
                db.insertCVE(item)
        # get the 'recent' file
        getfile = xml_file_prefix + file_rec + xml_file_suffix
        try:
            (f, r) = Configuration.getFile(Configuration.getFeedURL('cve_xml') + getfile)
        except:
            sys.exit("Cannot open url %s. Bad URL or not connected to the internet?"%(Configuration.getFeedURL("cve") + getfile))
        parser = make_parser()
        ch = CVEHandler()
        parser.setContentHandler(ch)
        parser.parse(f)
        for item in progressbar(ch.cves):
            # check if the CVE already exists.
            x = db.getCVE(item['id'])
            # if so, update the entry.
            if x:
                if args.v:
                    print("item found : " + item['id'])
                if 'cvss' not in item:
                    item['cvss'] = None
                else:
                    item['cvss'] = float(item['cvss'])
                if 'cwe' not in item:
                    item['cwe'] = defaultvalue['cwe']
                db.updateCVE(item)
            # if not, create it.
            else:
                db.insertCVE(item)
    elif args.s:
        create_map_of_software_versions()

    elif args.x:
        # populate is pretty straight-forward, just grab all the files from NVD
        # and dump them into a DB.
        c = db.getSize('cves')
        if args.v:
            print(str(c))
        if c > 0 and args.a is False:
            print("database already populated")
        else:
            print("Database population started")
            for x in range(cveStartYear, year):
                parser = make_parser()
                ch = CVEHandler()
                parser.setContentHandler(ch)
                getfile = xml_file_prefix + str(x) + xml_file_suffix
                try:
                    (f, r) = Configuration.getFile(Configuration.getFeedURL('cve_xml') + getfile)
                except:
                    sys.exit("Cannot open url %s. Bad URL or not connected to the internet?"%(Configuration.getFeedURL('cve') + getfile))
                parser.parse(f)
                if args.v:
                    for item in ch.cves:
                        print(item['id'])
                for item in ch.cves:
                    if 'cvss' in item:
                        item['cvss'] = float(item['cvss'])

                # check if year is not cve-free
                if len(ch.cves) != 0:
                    print("Importing CVEs for year " + str(x))
                    ret = db.insertCVE(ch.cves)
                else:
                    print ("Year " + str(x) + " has no CVE's.")

    elif args.j:
        # populate is pretty straight-forward, just grab all the files from NVD
        # and dump them into a DB.
        c = db.getSize('cves')
        LOGGER.debug('CVES size:'+str(c))
        if args.v:
            print(str(c))
        if c > 0 and args.a is False:
            print("database already populated")
            LOGGER.debug('Database already populated')
        else:
            print("Database population started")
            LOGGER.debug('Database population started')
            for x in range(cveStartYear, year):
                parser = CVESJsonParser()
                ch = CVEHandler()

                getfile = json_file_prefix + str(x) + json_file_suffix
                try:
                    (f, r) = Configuration.getFile(Configuration.getFeedURL('cve_json') + getfile)
                except:
                    sys.exit("Cannot open url %s. Bad URL or not connected to the internet?"%(Configuration.getFeedURL('cve_json') + getfile))

                parser.parse(f)

                if args.v:
                    for item in parser.cves:
                        print(item['id'])
                for item in parser.cves:
                    if 'cvss' in item:
                        item['cvss'] = float(item['cvss'])

                # check if year is not cve-free
                if len(parser.cves) != 0:
                    print("Importing CVEs for year " + str(x))
                    ret = db.insertCVE(parser.cves)
                else:
                    print ("Year " + str(x) + " has no CVE's.")